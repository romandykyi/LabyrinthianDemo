@inject MazeState MazeState

<MudGrid Justify="Justify.Center">
	<!-- Maze section -->
	<MudItem xs="12" sm="11" md="10" lg="5" xl="4">
		<MudPaper Class="pa-4">
			<MudText Typo="Typo.h5">Maze</MudText>
			<MudSelect T="MazeType" Label="Maze type" @bind-Value="mazeType">
				@foreach (MazeType mazeType in Enum.GetValues(typeof(MazeType)))
				{
					<MudSelectItem T="MazeType" Value="@mazeType">
						@mazeType.ToHumanReadableString()
					</MudSelectItem>
				}
			</MudSelect>
			<MudText Typo="Typo.h6">Size</MudText>
			<!-- Maze size selection -->
			@switch (mazeType)
			{
				<!-- Rectangular sizes -->
				case MazeType.Orthogonal or
					MazeType.RectangularDelta or
					MazeType.RectangularSigma or
					MazeType.Upsilon or
					MazeType.AlternativeUpsilon:
					<MudNumericField @bind-Value="width" Label="Width" Min="2" Max="100" />
					<MudNumericField @bind-Value="height" Label="Height" Min="2" Max="100" />
					if (mazeType != MazeType.AlternativeUpsilon)
					{
						<MudNumericField @bind-Value="inWidth" Label="Inner width" Min="0" Max="@(width - 2)" />
						<MudNumericField @bind-Value="inHeight" Label="Inner height" Min="0" Max="@(height - 2)" />
					}
					break;
				<!-- Hexagonal/Triangular sizes -->
				case MazeType.HexagonalSigma or MazeType.HexagonalDelta or
					MazeType.TriangularDelta:
					<MudNumericField @bind-Value="sideLength" Label="Side length" Min="2" Max="100" />
					<MudNumericField @bind-Value="inSideLength" Label="Inner side length" Min="2" Max="@(sideLength - 2)" />
					break;
				<!-- Circular sizes -->
				case MazeType.Theta:
					<MudNumericField @bind-Value="radius" Label="Radius" Min="3" Max="100" />
					<MudNumericField @bind-Value="inRadius" Label="Inner radius" Min="2" Max="@(radius - 2)" />
					<MudNumericField @bind-Value="segments" Label="Segments" Min="5" Max="150" />
					break;
			}
		</MudPaper>
	</MudItem>
	<!-- Generation section -->
	<MudItem xs="12" sm="11" md="10" lg="5" xl="4">
		<MudPaper Class="pa-4">
			<MudText Typo="Typo.h5">Generation</MudText>
			<MudSelect T="GenerationAlgorithm" Label="Generation algorithm" @bind-Value="algorithm">
				@foreach (GenerationAlgorithm algorithm in Enum.GetValues(typeof(GenerationAlgorithm)))
				{
					<MudSelectItem T="GenerationAlgorithm"
								   Disabled="IsAlgorithmDisabled(algorithm)"
								   Value="@algorithm">
						@algorithm.ToHumanReadableString()
					</MudSelectItem>
				}
			</MudSelect>
			<MudButton OnClick="Generate"
					   Color="Color.Primary" Variant="Variant.Filled">
				Generate
			</MudButton>
		</MudPaper>
	</MudItem>
</MudGrid>

@code {
	private GenerationAlgorithm algorithm { get; set; }
	private MazeType mazeType { get; set; }

	// Rectangular sizes
	private int width { get; set; } = 15;
	private int height { get; set; } = 15;
	private int inWidth { get; set; } = 0;
	private int inHeight { get; set; } = 0;
	// Hexagonal/Triangular sizes
	private int sideLength { get; set; } = 10;
	private int inSideLength { get; set; } = 0;
	// Circular sizes
	private int radius { get; set; } = 15;
	private int inRadius { get; set; } = 0;
	private int segments { get; set; } = 20;

	// Checks whether generation algorithm is compatible with current maze type
	private bool IsAlgorithmDisabled(GenerationAlgorithm algorithm)
	{
		// All algorithms support orthogonal and theta mazes
		if (mazeType == MazeType.Theta || mazeType == MazeType.Orthogonal)
			return false;

		// These algorithms are compatible only with orthogonal and theta mazes
		return algorithm == GenerationAlgorithm.BinaryTree ||
			algorithm == GenerationAlgorithm.RecursiveDivision ||
			algorithm == GenerationAlgorithm.Sidewinder;
	}

	// Generate a maze based on user input
	private async Task Generate()
	{
		// Select a maze type
		Maze maze = mazeType switch
		{
			MazeType.Orthogonal => new OrthogonalMaze(width, height, inWidth, inHeight),
			MazeType.Theta => new ThetaMaze(radius, inRadius, segments),
			MazeType.TriangularDelta => new DeltaMaze(sideLength, inSideLength),
			MazeType.RectangularDelta => new DeltaMaze(width, height, inWidth, inHeight),
			MazeType.HexagonalDelta => DeltaMaze.CreateHexagonal(sideLength, inSideLength),
			MazeType.RectangularSigma => new SigmaMaze(width, height, inWidth, inHeight),
			MazeType.HexagonalSigma => new SigmaMaze(sideLength, inSideLength),
			MazeType.Upsilon => new UpsilonMaze(width, height, inWidth, inHeight),
			MazeType.AlternativeUpsilon => new AlternativeUpsilonMaze(width, height),
			_ => throw new InvalidOperationException("Invalid maze type was selected")
		};
		// Select a generation algorithm
		MazeGenerator generator = algorithm switch
		{
			GenerationAlgorithm.AldousBroder => new AldousBroderGeneration(maze),
			GenerationAlgorithm.BinaryTree => new BinaryTreeGeneration(maze),
			GenerationAlgorithm.DepthFirstSearch => new DFSGeneration(maze),
			GenerationAlgorithm.EdgeBasedPrim => new EdgeBasedPrimGeneration(maze),
			GenerationAlgorithm.GrowingTree => new GrowingTreeGeneration(maze),
			GenerationAlgorithm.HuntAndKill => new HuntAndKillGeneration(maze),
			GenerationAlgorithm.Kruskal => new KruskalGeneration(maze),
			GenerationAlgorithm.Prim => new PrimGeneration(maze),
			GenerationAlgorithm.RecursiveBacktracker => new RecursiveBacktrackerGeneration(maze),
			GenerationAlgorithm.RecursiveDivision => new RecursiveDivisionGeneration(maze),
			GenerationAlgorithm.Sidewinder => new SidewinderGeneration(maze),
			GenerationAlgorithm.Wilson => new WilsonGeneration(maze),
			_ => throw new InvalidOperationException("Invalid generation algorithm was selected")
		};

		// Generate a maze
		generator.Generate();

		// Update the state
		await MazeState.UpdateMazeAsync(maze);
	}
}